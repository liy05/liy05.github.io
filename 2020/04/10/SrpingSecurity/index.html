<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>SrpingSecurity | li yang</title><meta name="description" content="SrpingSecurity"><meta name="keywords" content="spring security"><meta name="author" content="li yang"><meta name="copyright" content="li yang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="SrpingSecurity"><meta name="twitter:description" content="SrpingSecurity"><meta name="twitter:image" content="http://liy05.github.io/img/post.jpg"><meta property="og:type" content="article"><meta property="og:title" content="SrpingSecurity"><meta property="og:url" content="http://liy05.github.io/2020/04/10/SrpingSecurity/"><meta property="og:site_name" content="li yang"><meta property="og:description" content="SrpingSecurity"><meta property="og:image" content="http://liy05.github.io/img/post.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><link rel="stylesheet" href="/css/index.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://liy05.github.io/2020/04/10/SrpingSecurity/"><link rel="next" title="spring security oauth2 配置" href="http://liy05.github.io/2020/04/10/oauth2/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">1</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring-Security：认证和授权深入"><span class="toc-number">1.</span> <span class="toc-text">Spring Security：认证和授权深入</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#本文来源：https-www-marcobehler-com-guides-spring-security"><span class="toc-number">1.1.</span> <span class="toc-text">本文来源：https:&#x2F;&#x2F;www.marcobehler.com&#x2F;guides&#x2F;spring-security</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#介绍"><span class="toc-number">1.2.</span> <span class="toc-text">介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是Spring-Security，它如何工作？"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是Spring Security，它如何工作？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web应用程序安全性：101"><span class="toc-number">1.3.</span> <span class="toc-text">Web应用程序安全性：101</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-认证"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-授权"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.授权</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Servlet过滤器"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. Servlet过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#为什么要使用Servlet过滤器？"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">为什么要使用Servlet过滤器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#天真的SecurityFilter"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">天真的SecurityFilter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#过滤链"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">过滤链</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FilterChain和安全配置DSL"><span class="toc-number">1.4.</span> <span class="toc-text">FilterChain和安全配置DSL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring的DefaultSecurityFilterChain"><span class="toc-number">1.4.1.</span> <span class="toc-text">Spring的DefaultSecurityFilterChain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分析Spring的FilterChain"><span class="toc-number">1.4.2.</span> <span class="toc-text">分析Spring的FilterChain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何配置Spring-Security：WebSecurityConfigurerAdapter"><span class="toc-number">1.4.3.</span> <span class="toc-text">如何配置Spring Security：WebSecurityConfigurerAdapter</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#如何使用Spring-Security的配置DSL"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">如何使用Spring Security的配置DSL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#摘要：WebSecurityConfigurerAdapter的DSL配置"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">摘要：WebSecurityConfigurerAdapter的DSL配置</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Spring-Security进行身份验证"><span class="toc-number">1.5.</span> <span class="toc-text">使用Spring Security进行身份验证</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-UserDetailsService：有权访问用户的密码"><span class="toc-number">1.5.1.</span> <span class="toc-text">1. UserDetailsService：有权访问用户的密码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#现成的实现"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">现成的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#完整的UserDetails工作流程：HTTP基本身份验证"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">完整的UserDetails工作流程：HTTP基本身份验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#密码编码器"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">密码编码器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#摘要：有权访问用户的密码"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">摘要：有权访问用户的密码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AuthenticationProvider：无法访问用户密码"><span class="toc-number">1.5.2.</span> <span class="toc-text">2. AuthenticationProvider：无法访问用户密码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#完整的AuthenticationProvider工作流程：HTTP基本身份验证"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">完整的AuthenticationProvider工作流程：HTTP基本身份验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#摘要：AuthenticationProvider"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">摘要：AuthenticationProvider</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Spring-Security授权"><span class="toc-number">1.6.</span> <span class="toc-text">使用Spring Security授权</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是授权？"><span class="toc-number">1.6.1.</span> <span class="toc-text">什么是授权？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是当局？什么是角色？"><span class="toc-number">1.6.2.</span> <span class="toc-text">什么是当局？什么是角色？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为什么在角色和权限之间有区别？"><span class="toc-number">1.6.3.</span> <span class="toc-text">为什么在角色和权限之间有区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是GrantedAuthorities？什么是SimpleGrantedAuthorities？"><span class="toc-number">1.6.4.</span> <span class="toc-text">什么是GrantedAuthorities？什么是SimpleGrantedAuthorities？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-UserDetailsService：在哪里存储和获取授权？"><span class="toc-number">1.6.5.</span> <span class="toc-text">1. UserDetailsService：在哪里存储和获取授权？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-AuthenticationManager：在哪里存储和获取授权？"><span class="toc-number">1.6.6.</span> <span class="toc-text">2. AuthenticationManager：在哪里存储和获取授权？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重新访问WebSecurityConfigurerAdapter以获得权限"><span class="toc-number">1.6.7.</span> <span class="toc-text">重新访问WebSecurityConfigurerAdapter以获得权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hasAccess和SpEL"><span class="toc-number">1.6.8.</span> <span class="toc-text">hasAccess和SpEL</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常见漏洞利用保护"><span class="toc-number">1.7.</span> <span class="toc-text">常见漏洞利用保护</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#跨站请求伪造：CSRF"><span class="toc-number">1.7.1.</span> <span class="toc-text">跨站请求伪造：CSRF</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF和服务器端呈现的HTML"><span class="toc-number">1.7.1.1.</span> <span class="toc-text">CSRF和服务器端呈现的HTML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF代币和胸腺"><span class="toc-number">1.7.1.2.</span> <span class="toc-text">CSRF代币和胸腺</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF和其他模板库"><span class="toc-number">1.7.1.3.</span> <span class="toc-text">CSRF和其他模板库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CSRF＆React或Angular"><span class="toc-number">1.7.1.4.</span> <span class="toc-text">CSRF＆React或Angular</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁用CSRF"><span class="toc-number">1.7.1.5.</span> <span class="toc-text">禁用CSRF</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OAuth2"><span class="toc-number">1.8.</span> <span class="toc-text">OAuth2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#春季整合"><span class="toc-number">1.9.</span> <span class="toc-text">春季整合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring安全性和Spring框架"><span class="toc-number">1.9.1.</span> <span class="toc-text">Spring安全性和Spring框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法安全性"><span class="toc-number">1.9.2.</span> <span class="toc-text">方法安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PreAuthorize，-Secured和-RolesAllowed有什么区别？"><span class="toc-number">1.9.3.</span> <span class="toc-text">@ PreAuthorize，@ Secured和@RolesAllowed有什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#我应该使用哪个注释？"><span class="toc-number">1.9.4.</span> <span class="toc-text">我应该使用哪个注释？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Security和Spring-Web-MVC"><span class="toc-number">1.9.5.</span> <span class="toc-text">Spring Security和Spring Web MVC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Security和Spring-Boot"><span class="toc-number">1.9.6.</span> <span class="toc-text">Spring Security和Spring Boot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#春季安全与胸腺"><span class="toc-number">1.9.7.</span> <span class="toc-text">春季安全与胸腺</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常问问题"><span class="toc-number">1.10.</span> <span class="toc-text">常问问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是最新的Spring-Security版本？"><span class="toc-number">1.10.1.</span> <span class="toc-text">什么是最新的Spring Security版本？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#较旧的Spring-Security版本与最新版本兼容吗？"><span class="toc-number">1.10.2.</span> <span class="toc-text">较旧的Spring Security版本与最新版本兼容吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为了使Spring-Security正常工作，我需要添加哪些依赖项？"><span class="toc-number">1.10.3.</span> <span class="toc-text">为了使Spring Security正常工作，我需要添加哪些依赖项？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#平原春季项目"><span class="toc-number">1.10.3.1.</span> <span class="toc-text">平原春季项目</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#春季启动项目"><span class="toc-number">1.10.3.2.</span> <span class="toc-text">春季启动项目</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何在Spring-Security中以编程方式访问当前经过身份验证的用户？"><span class="toc-number">1.10.4.</span> <span class="toc-text">如何在Spring Security中以编程方式访问当前经过身份验证的用户？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AntMatchers：常见示例"><span class="toc-number">1.10.5.</span> <span class="toc-text">AntMatchers：常见示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何在Spring-Security中使用自定义登录页面？"><span class="toc-number">1.10.6.</span> <span class="toc-text">如何在Spring Security中使用自定义登录页面？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何使用Spring-Security进行程序化登录？"><span class="toc-number">1.10.7.</span> <span class="toc-text">如何使用Spring Security进行程序化登录？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何仅针对某些路径禁用CSRF？"><span class="toc-number">1.10.8.</span> <span class="toc-text">如何仅针对某些路径禁用CSRF？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#鳍"><span class="toc-number">1.11.</span> <span class="toc-text">鳍</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(/img/post.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">li yang</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">SrpingSecurity</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-10 17:15:02"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-10</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-04-12 19:04:12"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-04-12</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/JAVA/">JAVA</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h1 id="Spring-Security：认证和授权深入"><a href="#Spring-Security：认证和授权深入" class="headerlink" title="Spring Security：认证和授权深入"></a>Spring Security：认证和授权深入</h1><h2 id="本文来源：https-www-marcobehler-com-guides-spring-security"><a href="#本文来源：https-www-marcobehler-com-guides-spring-security" class="headerlink" title="本文来源：https://www.marcobehler.com/guides/spring-security"></a>本文来源：<a href="https://www.marcobehler.com/guides/spring-security" target="_blank" rel="noopener">https://www.marcobehler.com/guides/spring-security</a></h2><p>讲的很深入，google机翻。mark</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>每个人迟早都需要为他的项目增加安全性，在Spring生态系统中，您可以借助<a href="https://spring.io/projects/spring-security" target="_blank" rel="noopener">Spring Security</a>库来做到这一点。</p>
<p>因此，您继续将Spring Security添加到您的Spring Boot（或普通<a href="https://www.marcobehler.com/guides/spring-framework" target="_blank" rel="noopener">Spring</a>）项目中，然后突然…</p>
<ul>
<li>…您有自动生成的登录页面。</li>
<li>…您无法再执行POST请求。</li>
<li>…您的整个应用程序处于锁定状态，并提示您输入用户名和密码。</li>
</ul>
<p>在随后的精神崩溃中幸存下来之后，您可能会对所有这些工作原理感兴趣。</p>
<h3 id="什么是Spring-Security，它如何工作？"><a href="#什么是Spring-Security，它如何工作？" class="headerlink" title="什么是Spring Security，它如何工作？"></a>什么是Spring Security，它如何工作？</h3><p><strong>简短的答案</strong>：</p>
<p>从本质上讲，Spring Security实际上只是一堆servlet过滤器，可帮助您向Web应用程序添加<a href="https://www.marcobehler.com/guides/spring-security#authentication-explained" target="_blank" rel="noopener">身份验证</a>和<a href="https://www.marcobehler.com/guides/spring-security#authorization-explained" target="_blank" rel="noopener">授权</a>。</p>
<p>它还与Spring Web MVC（或<a href="https://www.marcobehler.com/guides/spring-boot" target="_blank" rel="noopener">Spring Boot</a>）之类的框架以及OAuth2或SAML之类的标准很好地集成。并且它会自动生成登录/注销页面，并防御CSRF等常见漏洞。</p>
<p>现在，那真的没有帮助，是吗？</p>
<p><strong>幸运的是，答案很长</strong>：</p>
<p>本文的其余部分。</p>
<h2 id="Web应用程序安全性：101"><a href="#Web应用程序安全性：101" class="headerlink" title="Web应用程序安全性：101"></a>Web应用程序安全性：101</h2><p>在成为Spring Security Guru之前，您需要了解三个重要概念：</p>
<ol>
<li>认证方式</li>
<li>授权书</li>
<li>Servlet过滤器</li>
</ol>
<p><strong>家长建议</strong>：不要跳过本节，因为它是Spring Security所做的<em>一切</em>的基础。另外，我将使其尽可能有趣。</p>
<h3 id="1-认证"><a href="#1-认证" class="headerlink" title="1.认证"></a>1.认证</h3><p>首先，如果您正在运行典型的（网络）应用程序，则需要您的用户进行<em>身份验证</em>。这意味着您的应用需求，以验证用户是否是<em>谁</em>，他声称自己是，通常与一个用户名和密码检查完成。</p>
<p><strong>用户</strong>：“我是美国总统。我<code>*username*</code>是：potus！”</p>
<p><strong>您的web应用程序</strong>：“当然<code>*password*</code>，总统先生，您那是什么？”</p>
<p><strong>用户</strong>：“我的密码是：th3don4ld”。</p>
<p><strong>您的网络应用程序</strong>：“正确。欢迎您，先生！”</p>
<h3 id="2-授权"><a href="#2-授权" class="headerlink" title="2.授权"></a>2.授权</h3><p>在更简单的应用程序中，身份验证可能就足够了：用户进行身份验证后，便可以访问应用程序的每个部分。</p>
<p>但是大多数应用程序都有权限（或角色）的概念。想象一下：有权访问您的Webshop面向公众的前端的客户，以及有权访问单独的管理区域的管理员。</p>
<p>两种类型的用户都需要登录，但是仅凭身份验证并不能说明他们在系统中可以执行的操作。因此，您还需要检查经过身份验证的用户的权限，即需要<em>授权</em>用户。</p>
<p><strong>用户</strong>：“让我玩那个核足球……”。</p>
<p><strong>您的web应用程序</strong>：`<em>permissions</em>```请稍等一会，我需要检查一下….是的，主席先生，您的权限级别正确。请尽情享受。</p>
<p><strong>用户</strong>：“那个红色按钮又是什么……？”</p>
<h3 id="3-Servlet过滤器"><a href="#3-Servlet过滤器" class="headerlink" title="3. Servlet过滤器"></a>3. Servlet过滤器</h3><p>最后但并非最不重要的一点，让我们看一下Servlet过滤器。他们与身份验证和授权有什么关系？（如果您是Java Servlet或过滤器的新手，建议您阅读旧的但仍然非常有效的<a href="http://shop.oreilly.com/product/9780596005405.do" target="_blank" rel="noopener">Head First Servlets</a>书。）</p>
<h4 id="为什么要使用Servlet过滤器？"><a href="#为什么要使用Servlet过滤器？" class="headerlink" title="为什么要使用Servlet过滤器？"></a>为什么要使用Servlet过滤器？</h4><p>回想一下我的<a href="https://www.marcobehler.com/guides/spring-framework" target="_blank" rel="noopener">另一篇文章</a>，我们发现基本上任何Spring Web应用程序都<em>只是</em>一个servlet：Spring的老版本<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet" target="_blank" rel="noopener">DispatcherServlet</a>，它将传入的HTTP请求（例如从浏览器）重定向到您的@Controllers或@RestControllers。</p>
<p>关键是：该DispatcherServlet中没有安全编码，您也很可能不想在@Controllers中摸索原始的HTTP Basic Auth标头。最佳情况下，应该<em>在</em>请求到达您的@Controllers <em>之前</em>完成身份验证和授权。</p>
<p>幸运的是，在Java网络世界中，有一种方法可以做到这一点：您可以将<a href="https://www.oracle.com/technetwork/java/filters-137243.html" target="_blank" rel="noopener">过滤器</a> <em>放在</em> servlet的<em>前面</em>，这意味着您可以考虑编写SecurityFilter并在Tomcat（servlet容器/应用程序服务器）中对其进行配置以过滤所有传入的信息命中servlet之前的HTTP请求。</p>
<p><img src="/" class="lazyload" data-src="/2020/04/10/SrpingSecurity/servletfilter-1a.png"  alt="servlet过滤器1a"></p>
<h4 id="天真的SecurityFilter"><a href="#天真的SecurityFilter" class="headerlink" title="天真的SecurityFilter"></a>天真的SecurityFilter</h4><p>一个SecurityFilter大约有4个任务，一个过分简单的实现可能看起来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityServletFilter</span> <span class="keyword">extends</span> <span class="title">HttpFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"></span><br><span class="line">        UsernamePasswordToken token = extractUsernameAndPasswordFrom(request);  <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (notAuthenticated(token)) &#123;  <span class="comment">// (2)</span></span><br><span class="line">            <span class="comment">// either no or wrong username/password</span></span><br><span class="line">            <span class="comment">// unfortunately the HTTP status code is called "unauthorized", instead of "unauthenticated"</span></span><br><span class="line">            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED); <span class="comment">// HTTP 401.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (notAuthorized(token, request)) &#123; <span class="comment">// (3)</span></span><br><span class="line">            <span class="comment">// you are logged in, but don't have the proper rights</span></span><br><span class="line">            response.setStatus(HttpServletResponse.SC_FORBIDDEN); <span class="comment">// HTTP 403</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// allow the HttpRequest to go to Spring's DispatcherServlet</span></span><br><span class="line">        <span class="comment">// and @RestControllers/@Controllers.</span></span><br><span class="line">        chain.doFilter(request, response); <span class="comment">// (4)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> UsernamePasswordToken <span class="title">extractUsernameAndPasswordFrom</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Either try and read in a Basic Auth HTTP Header, which comes in the form of user:password</span></span><br><span class="line">        <span class="comment">// Or try and find form login request parameters or POST bodies, i.e. "username=me" &amp; "password="myPass"</span></span><br><span class="line">        <span class="keyword">return</span> checkVariousLoginOptions(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">notAuthenticated</span><span class="params">(UsernamePasswordToken token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// compare the token with what you have in your database...or in-memory...or in LDAP...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">notAuthorized</span><span class="params">(UsernamePasswordToken token, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// check if currently authenticated user has the permission/role to access this request's /URI</span></span><br><span class="line">       <span class="comment">// e.g. /admin needs a ROLE_ADMIN , /callcenter needs ROLE_CALLCENTER, etc.</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>首先，过滤器需要从请求中提取用户名/密码。它可以通过<a href="https://en.wikipedia.org/wiki/Basic_access_authentication" target="_blank" rel="noopener">Basic Auth HTTP Header</a>，表单字段或Cookie等进行。</li>
<li>然后，筛选器需要针对诸如数据库之类的<em>东西</em>来验证该用户名/密码组合。</li>
<li>过滤器需要在成功认证后检查用户是否有权访问所请求的URI。</li>
<li>如果该请求在所有这些检查中<em>仍然存在</em>，则过滤器可以使该请求通过您的DispatcherServlet，即@Controllers。</li>
</ol>
<h4 id="过滤链"><a href="#过滤链" class="headerlink" title="过滤链"></a>过滤链</h4><p>现实检查：上面的代码可以编译时，迟早会导致一个带有大量用于各种身份验证和授权机制的代码的怪兽过滤器。</p>
<p>但是，在现实世界中，您可以将此过滤器拆分为<em>多个</em>过滤器，然后将它们<em>链接</em>在一起。</p>
<p>例如，传入的HTTP请求将…</p>
<ol>
<li>首先，通过LoginMethodFilter …</li>
<li>然后，通过AuthenticationFilter …</li>
<li>然后，通过AuthorizationFilter …</li>
<li>最后，点击您的servlet。</li>
</ol>
<p>这个概念称为<em>FilterChain</em>，上面过滤器中的最后一个方法调用实际上委托给了那个链：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chain.doFilter(request, response);</span><br></pre></td></tr></table></figure>

<p>使用这种过滤器（链），您基本上可以处理应用程序中存在的每个身份验证或授权问题，而无需更改实际的应用程序实现（请考虑：@RestControllers / @Controllers）。</p>
<p>有了这些知识，让我们了解一下Spring Security如何利用这种过滤器魔术。</p>
<h2 id="FilterChain和安全配置DSL"><a href="#FilterChain和安全配置DSL" class="headerlink" title="FilterChain和安全配置DSL"></a>FilterChain和安全配置DSL</h2><p>我们将以与上一章相反的方向开始，以非常规的方式介绍Spring Security，从Spring Security的FilterChain开始。</p>
<h3 id="Spring的DefaultSecurityFilterChain"><a href="#Spring的DefaultSecurityFilterChain" class="headerlink" title="Spring的DefaultSecurityFilterChain"></a>Spring的DefaultSecurityFilterChain</h3><p>假设您正确<a href="https://www.marcobehler.com/guides/spring-security#spring-security-dependencies" target="_blank" rel="noopener">设置了Spring Security</a>，然后启动了Web应用程序。您将看到以下日志消息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2020-02-25 10:24:27.875  INFO 11116 --- [           main] o.s.s.web.DefaultSecurityFilterChain     : Creating filter chain: any request, [org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter@46320c9a, org.springframework.security.web.context.SecurityContextPersistenceFilter@4d98e41b, org.springframework.security.web.header.HeaderWriterFilter@52bd9a27, org.springframework.security.web.csrf.CsrfFilter@51c65a43, org.springframework.security.web.authentication.logout.LogoutFilter@124d26ba, org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter@61e86192, org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter@10980560, org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter@32256e68, org.springframework.security.web.authentication.www.BasicAuthenticationFilter@52d0f583, org.springframework.security.web.savedrequest.RequestCacheAwareFilter@5696c927, org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter@5f025000, org.springframework.security.web.authentication.AnonymousAuthenticationFilter@5e7abaf7, org.springframework.security.web.session.SessionManagementFilter@681c0ae6, org.springframework.security.web.access.ExceptionTranslationFilter@15639d09, org.springframework.security.web.access.intercept.FilterSecurityInterceptor@4f7be6c8]|</span><br></pre></td></tr></table></figure>

<p>如果将这一行扩展到列表中，Spring Security似乎不仅会安装<em>一个</em>过滤器，还会安装由15个（！）不同过滤器组成的整个过滤器链。</p>
<p>因此，当HTTPRequest传入时，它将通过<em>所有</em>这15个过滤器，直到您的请求最终到达@RestControllers为止。顺序也很重要，从该列表的顶部开始，一直到底部。</p>
<p><img src="/" class="lazyload" data-src="/2020/04/10/SrpingSecurity/filterchain-1a.png"  alt="过滤链1a"></p>
<h3 id="分析Spring的FilterChain"><a href="#分析Spring的FilterChain" class="headerlink" title="分析Spring的FilterChain"></a>分析Spring的FilterChain</h3><p>详细了解该链中的每个过滤器都太过分了，但是这里是其中一些过滤器的解释。随意查看<a href="https://github.com/spring-projects/spring-security" target="_blank" rel="noopener">Spring Security的源代码</a>以了解其他过滤器。</p>
<ul>
<li><strong>BasicAuthenticationFilter</strong>：尝试在请求中查找基本身份验证HTTP标头，如果找到，则尝试使用标头的用户名和密码对用户进行身份验证。</li>
<li><strong>UsernamePasswordAuthenticationFilter</strong>：尝试查找用户名/密码请求参数/ POST正文，如果找到，则尝试使用这些值对用户进行身份验证。</li>
<li><strong>DefaultLoginPageGeneratingFilter</strong>：如果您没有明确禁用该功能，则为您生成一个登录页面。这是启用Spring Security时获得默认登录页面的原因。</li>
<li><strong>DefaultLogoutPageGeneratingFilter</strong>：如果您未明确禁用该功能，则为您生成一个注销页面。</li>
<li><strong>FilterSecurityInterceptor</strong>：执行您的授权。</li>
</ul>
<p>因此，通过这两个过滤器，Spring Security为您提供了一个登录/注销页面，并提供了使用基本身份验证或表单登录进行登录的功能，以及一些其他功能，例如CsrfFilter，我们将拥有一个以后再看。</p>
<p><strong>Half-Time Break</strong>：这些过滤器在很大程度上<em>是</em> Spring Security。不多不少。他们完成所有工作。剩下要做的就是<em>配置</em>它们的工作方式，即要保护的URL，要忽略的URL以及要用于身份验证的数据库表。</p>
<p>因此，接下来我们需要看看如何配置Spring Security。</p>
<h3 id="如何配置Spring-Security：WebSecurityConfigurerAdapter"><a href="#如何配置Spring-Security：WebSecurityConfigurerAdapter" class="headerlink" title="如何配置Spring Security：WebSecurityConfigurerAdapter"></a>如何配置Spring Security：WebSecurityConfigurerAdapter</h3><p>使用最新的Spring Security和/或Spring Boot版本，配置Spring Security的方法是通过具有以下类：</p>
<ol>
<li>用@EnableWebSecurity注释。</li>
<li>扩展了WebSecurityConfigurer，它基本上为您提供了配置DSL /方法。使用这些方法，您可以指定应用程序中要保护的URI或要启用/禁用的漏洞利用保护。</li>
</ol>
<p>这是典型的WebSecurityConfigurerAdapter的外观：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span> <span class="comment">// (1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123; <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;  <span class="comment">// (2)</span></span><br><span class="line">      http</span><br><span class="line">        .authorizeRequests()</span><br><span class="line">          .antMatchers(<span class="string">"/"</span>, <span class="string">"/home"</span>).permitAll() <span class="comment">// (3)</span></span><br><span class="line">          .anyRequest().authenticated() <span class="comment">// (4)</span></span><br><span class="line">          .and()</span><br><span class="line">       .formLogin() <span class="comment">// (5)</span></span><br><span class="line">         .loginPage(<span class="string">"/login"</span>) <span class="comment">// (5)</span></span><br><span class="line">         .permitAll()</span><br><span class="line">         .and()</span><br><span class="line">      .logout() <span class="comment">// (6)</span></span><br><span class="line">        .permitAll()</span><br><span class="line">        .and()</span><br><span class="line">      .httpBasic(); <span class="comment">// (7)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>带有@EnableWebSecurity批注的常规Spring @Configuration，从WebSecurityConfigurerAdapter扩展。</li>
<li>通过重写适配器的configure（HttpSecurity）方法，您将获得一个不错的小DSL，可用来配置FilterChain。</li>
<li>所有请求去<code>*/*</code>和<code>*/home*</code>被允许（允许） -用户就<em>不能</em>有进行身份验证。您正在使用<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/AntPathMatcher.html" target="_blank" rel="noopener">antMatcher</a>，这意味着您还可以在字符串中使用通配符（*，\ * \ * <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/AntPathMatcher.html" target="_blank" rel="noopener">，？</a>）。</li>
<li>任何其他请求需要被认证的用户<em>的第一</em>，即，用户需要登录。</li>
<li>您正在允许使用自定义的loginPage（<code>*/login*</code>即不是Spring Security的自动生成的）登录表单（表单中的用户名/密码）。任何人都应该能够访问登录页面，而无需先登录（permitAll；否则我们将获得Catch-22！）。</li>
<li>注销页面也一样</li>
<li>最重要的是，您还允许基本身份验证，即发送HTTP基本身份验证标头进行身份验证。</li>
</ol>
<h4 id="如何使用Spring-Security的配置DSL"><a href="#如何使用Spring-Security的配置DSL" class="headerlink" title="如何使用Spring Security的配置DSL"></a>如何使用Spring Security的配置DSL</h4><p>习惯了该DSL需要花费一些时间，但是您可以在FAQ部分中找到更多示例：<a href="https://www.marcobehler.com/guides/spring-security#security-examples" target="_blank" rel="noopener">AntMatchers：常见示例</a>。</p>
<p>现在重要的是，<em>此</em> <code>*configure*</code>方法是您指定的位置：</p>
<ol>
<li>要保护的URL（authenticated（））和允许的URL（permitAll（））。</li>
<li>允许哪些身份验证方法（formLogin（），httpBasic（））及其配置方式。</li>
<li>简而言之：您的应用程序的完整安全性配置。</li>
</ol>
<p><strong>注意</strong>：您不需要立即重写适配器的configure方法，因为它带有相当合理的实现-默认情况下。看起来是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfigurerAdapter</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">                <span class="title">WebSecurityConfigurer</span>&lt;<span class="title">WebSecurity</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                    .anyRequest().authenticated()  <span class="comment">// (1)</span></span><br><span class="line">                    .and()</span><br><span class="line">                .formLogin().and()   <span class="comment">// (2)</span></span><br><span class="line">                .httpBasic();  <span class="comment">// (3)</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>要访问应用程序上的<em>任何</em> URI（<code>*anyRequest()*</code>），您需要进行身份验证（authenticated（））。</li>
<li><code>*formLogin()*</code>使用默认设置的表单登录（）已启用。</li>
<li>和HTTP基本身份验证（<code>*httpBasic()*</code>）一样。</li>
</ol>
<p><em>这种</em>默认配置是您在向其添加Spring Security之后立即将其锁定的原因。很简单，不是吗？</p>
<h4 id="摘要：WebSecurityConfigurerAdapter的DSL配置"><a href="#摘要：WebSecurityConfigurerAdapter的DSL配置" class="headerlink" title="摘要：WebSecurityConfigurerAdapter的DSL配置"></a>摘要：WebSecurityConfigurerAdapter的DSL配置</h4><p>我们了解到，Spring Security由使用WebSecurityConfigurerAdapter @Configuration类配置的几个过滤器组成。</p>
<p>但是缺少一个关键的部分。让我们以Spring的BasicAuthFilter为例。它可以从HTTP Basic Auth标头提取用户名/密码，但是对这些凭证进行<em>身份验证</em>又是基于什么呢？</p>
<p>这自然使我们想到了身份验证如何与Spring Security一起工作的问题。</p>
<h2 id="使用Spring-Security进行身份验证"><a href="#使用Spring-Security进行身份验证" class="headerlink" title="使用Spring Security进行身份验证"></a>使用Spring Security进行身份验证</h2><p>在身份验证和Spring Security方面，您大致有以下三种情况：</p>
<ol>
<li>该<strong>默认</strong>：您<em>可以</em>访问用户的（加密）密码，因为你有他保存在例如数据库表的详细信息（用户名，密码）。</li>
<li><strong>不太常见</strong>：您<em>无法</em>访问用户的（加密）密码。如果您的用户和密码存储在<em>其他</em>地方，例如在提供身份验证的REST服务的第三方身份管理产品中，就属于这种情况。认为：<a href="https://www.atlassian.com/software/crowd" target="_blank" rel="noopener">Atlassian人群</a>。</li>
<li><strong>也很受欢迎</strong>：您想使用OAuth2或“使用Google / Twitter / etc登录”。（OpenID），可能与JWT结合使用。然后，以下任何一项都不适用，您应该直接进入<a href="https://www.marcobehler.com/guides/spring-security#oauth2" target="_blank" rel="noopener">OAuth2一章</a>。</li>
</ol>
<p><strong>注意</strong>：根据您的情况，您需要指定不同的@Beans才能使Spring Security正常工作，否则最终将获得非常混乱的异常（例如，如果您忘记指定PasswordEncoder，则为NullPointerException）。记住这一点。</p>
<p>让我们看一下前两种情况。</p>
<h3 id="1-UserDetailsService：有权访问用户的密码"><a href="#1-UserDetailsService：有权访问用户的密码" class="headerlink" title="1. UserDetailsService：有权访问用户的密码"></a>1. UserDetailsService：有权访问用户的密码</h3><p>假设您有一个存储用户的数据库表。它有几列，但最重要的是，它有一个用户名和密码列，您可以在其中存储用户的已加密（！）密码。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="keyword">users</span> (<span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>, username <span class="built_in">varchar</span>(<span class="number">255</span>), <span class="keyword">password</span> <span class="built_in">varchar</span>(<span class="number">255</span>));</span><br></pre></td></tr></table></figure>

<p>在这种情况下，Spring Security需要您定义两个bean以启动并运行身份验证。</p>
<ol>
<li>一个UserDetailsService。</li>
<li>密码编码器。</li>
</ol>
<p>指定UserDetailsService就是这样简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDetailsService <span class="title">userDetailsService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyDatabaseUserDetailsService(); <span class="comment">// (1)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>MyDatabaseUserDetailsService实现了UserDetailsService，这是一个非常简单的接口，由一个返回UserDetails对象的方法组成：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123; <span class="comment">// (1)</span></span><br><span class="line">         <span class="comment">// 1. Load the user from the users table by username. If not found, throw UsernameNotFoundException.</span></span><br><span class="line">         <span class="comment">// 2. Convert/wrap the user to a UserDetails object and return it.</span></span><br><span class="line">        <span class="keyword">return</span> someUserDetails;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123; <span class="comment">// (2)</span></span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;3&gt; more methods:</span></span><br><span class="line">    <span class="comment">// isAccountNonExpired,isAccountNonLocked,</span></span><br><span class="line">    <span class="comment">// isCredentialsNonExpired,isEnabled</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>UserDetailsService通过用户的用户名加载UserDetails。请注意，该方法<strong>仅采用</strong>一个参数：用户名（而不是密码）。</li>
<li>UserDetails界面具有获取（加密！）密码的方法和获取用户名的方法。</li>
<li>UserDetails拥有更多方法，例如帐户处于活动状态或被阻止，凭据已过期或用户具有什么权限-但是我们不在此介绍。</li>
</ol>
<p>因此，您可以像上面一样自行实现这些接口，也可以使用Spring Security提供的现有接口。</p>
<h4 id="现成的实现"><a href="#现成的实现" class="headerlink" title="现成的实现"></a>现成的实现</h4><p>简要说明一下：您始终可以自己实现UserDetailsService和UserDetails接口。</p>
<p>但是，您还会发现Spring Security提供的现成的实现，您可以改用/ configure / extend / override。</p>
<ol>
<li><strong>JdbcUserDetailsManager</strong>，这是一个基于JDBC（数据库）的UserDetailsService。您可以配置它以匹配您的<em>用户</em>表/列结构。</li>
<li><strong>InMemoryUserDetailsManager</strong>，它将所有用户详细信息保留在内存中，非常适合测试。</li>
<li><strong>org.springframework.security.core.userdetail.User</strong>，这是您可以使用的明智的默认UserDetails实现。这意味着您可能在实体/数据库表与该用户类之间进行映射/复制。或者，您可以简单地使您的实体实现UserDetails接口。</li>
</ol>
<h4 id="完整的UserDetails工作流程：HTTP基本身份验证"><a href="#完整的UserDetails工作流程：HTTP基本身份验证" class="headerlink" title="完整的UserDetails工作流程：HTTP基本身份验证"></a>完整的UserDetails工作流程：HTTP基本身份验证</h4><p>现在回想一下您的HTTP基本身份验证，这意味着您正在使用Spring Security和Basic Auth保护您的应用程序的安全。当您指定UserDetailsService并尝试登录时，将发生以下情况：</p>
<ol>
<li>从过滤器中的HTTP Basic Auth标头中提取用户名/密码组合。您无需为此做任何事情，它会在后台进行。</li>
<li>呼叫<em>你的</em> MyDatabaseUserDetailsService加载从数据库中相应的用户，包装成一个UserDetails对象，它暴露了用户的加密密码。</li>
<li>从HTTP Basic Auth标头中提取提取的密码，对其进行<em>自动</em>加密，并将其与UserDetails对象中的加密密码进行比较。如果两者都匹配，则说明用户已成功通过身份验证。</li>
</ol>
<p>这里的所有都是它的。但是等等，Spring Security <em>如何</em>加密来自客户端的密码（步骤3）？用什么算法？</p>
<h4 id="密码编码器"><a href="#密码编码器" class="headerlink" title="密码编码器"></a>密码编码器</h4><p>Spring Security无法神奇地猜测您首选的密码加密算法。这就是为什么您需要指定另一个@Bean，一个<em>PasswordEncoder的原因</em>。例如，如果要对<em>所有密码</em>使用BCrypt加密（Spring Security的默认设置），则可以在SecurityConfig中指定此@Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">bCryptPasswordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您有<em>多个</em>密码加密算法，因为您有一些旧用户的密码是用MD5存储的（不这样做），而较新的用户使用Bcrypt甚至是第三个算法（如SHA-256），该怎么办？然后，您将使用以下编码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PasswordEncoderFactories.createDelegatingPasswordEncoder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该委托编码器如何工作？它将查看UserDetail的加密密码（例如来自数据库表），该密码现在必须以开头<code>*{prefix}*</code>。该前缀是您的加密方法！您的数据库表将如下所示：</p>
<table>
<thead>
<tr>
<th>用户名</th>
<th>密码</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><a href="mailto:john@doe.com">john@doe.com</a></td>
<td>{bcrypt} $ 2y $ 12 $ 6t86Rpr3llMANhCUt26oUen2WhvXr / A89Xo9zJion8W7gWgZ / zA0C</td>
<td></td>
</tr>
<tr>
<td><a href="mailto:my@user.com">my@user.com</a></td>
<td>{sha256} 5ffa39f5757a0dad5dfada519d02c6b71b61ab1df51b4ed1f3beed6abe0ff5f6</td>
<td></td>
</tr>
</tbody></table>
<p>Spring Security将：</p>
<ol>
<li>读入这些密码并删除前缀（{bcrypt}或{sha256}）。</li>
<li>根据前缀值，使用正确的PasswordEncoder（即BCryptEncoder或SHA256Encoder）</li>
<li>使用该PasswordEncoder加密传入的未加密密码，并将其与存储的密码进行比较。</li>
</ol>
<p>这就是PasswordEncoders的全部内容。</p>
<h4 id="摘要：有权访问用户的密码"><a href="#摘要：有权访问用户的密码" class="headerlink" title="摘要：有权访问用户的密码"></a>摘要：有权访问用户的密码</h4><p>本部分的要点是：如果您正在使用Spring Security并有权访问用户的密码，则：</p>
<ol>
<li>指定一个UserDetailsService。定制实现或使用并配置Spring Security提供的实现。</li>
<li>指定一个PasswordEncoder。</li>
</ol>
<p>简而言之，就是Spring Security认证。</p>
<h3 id="2-AuthenticationProvider：无法访问用户密码"><a href="#2-AuthenticationProvider：无法访问用户密码" class="headerlink" title="2. AuthenticationProvider：无法访问用户密码"></a>2. AuthenticationProvider：无法访问用户密码</h3><p>现在，假设您正在使用<a href="https://www.atlassian.com/software/crowd" target="_blank" rel="noopener">Atlassian Crowd</a>进行集中身份管理。这意味着所有应用程序的所有用户和密码都存储在Atlassian Crowd中，而不再存储在数据库表中。</p>
<p>这有两个含义：</p>
<ol>
<li>您的应用程序中不再<em>有</em>用户密码，因为您不能要求Crowd仅给您这些密码。</li>
<li>但是，您确实拥有可以使用您的用户名和密码登录的REST API。（对<code>*/rest/usermanagement/1/authentication*</code>REST端点的POST请求 ）。</li>
</ol>
<p>在这种情况下，您不能再使用UserDetailsService，而需要实现并提供<strong>AuthenticationProvider</strong> @Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AuthenticationProvider <span class="title">authenticationProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AtlassianCrowdAuthenticationProvider();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AuthenticationProvider主要由一种方法组成，并且一个简单的实现可能看起来像这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtlassianCrowdAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span>  <span class="comment">// (1)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">            String username = authentication.getPrincipal().toString(); <span class="comment">// (1)</span></span><br><span class="line">            String password = authentication.getCredentials().toString(); <span class="comment">// (1)</span></span><br><span class="line"></span><br><span class="line">            User user = callAtlassianCrowdRestService(username, password); <span class="comment">// (2)</span></span><br><span class="line">            <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;                                     <span class="comment">// (3)</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"could not login"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UserNamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), user.getAuthorities()); <span class="comment">// (4)</span></span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">// other method ignored</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>与只能访问用户名的UserDetails load（）方法相比，现在可以访问完整的身份验证尝试，<em>通常</em>包含用户名和密码。</li>
<li>您可以执行任何想要验证用户身份的操作，例如，调用REST服务。</li>
<li>如果身份验证失败，则需要引发异常。</li>
<li>如果身份验证成功，则需要返回一个完全初始化的UsernamePasswordAuthenticationToken。它是Authentication接口的一种实现，需要将authenticated字段设置为true（上面使用的构造函数将自动设置该字段）。我们将在下一章介绍有关权限。</li>
</ol>
<h4 id="完整的AuthenticationProvider工作流程：HTTP基本身份验证"><a href="#完整的AuthenticationProvider工作流程：HTTP基本身份验证" class="headerlink" title="完整的AuthenticationProvider工作流程：HTTP基本身份验证"></a>完整的AuthenticationProvider工作流程：HTTP基本身份验证</h4><p>现在回想一下您的HTTP基本身份验证，这意味着您正在使用Spring Security和Basic Auth保护您的应用程序的安全。当您指定AuthenticationProvider并尝试登录时，将发生以下情况：</p>
<ol>
<li>从过滤器中的HTTP Basic Auth标头中提取用户名/密码组合。您无需为此做任何事情，它会在后台进行。</li>
<li>使用该用户名和密码调用<em>您的</em> AuthenticationProvider（例如AtlassianCrowdAuthenticationProvider），以便您自己进行身份验证（例如REST调用）。</li>
</ol>
<p>没有进行密码加密或类似操作，因为您实际上是委派第三方进行实际的用户名/密码检查。简而言之，这就是AuthenticationProvider身份验证！</p>
<h4 id="摘要：AuthenticationProvider"><a href="#摘要：AuthenticationProvider" class="headerlink" title="摘要：AuthenticationProvider"></a>摘要：AuthenticationProvider</h4><p>本部分的<em>要点</em>是：如果您使用的是Spring Security，<em>但没有</em>访问用户密码的权限，则请<em>实现并提供AuthenticationProvider @Bean</em>。</p>
<h2 id="使用Spring-Security授权"><a href="#使用Spring-Security授权" class="headerlink" title="使用Spring Security授权"></a>使用Spring Security授权</h2><p>到目前为止，我们仅讨论了身份验证，例如用户名和密码检查。</p>
<p>现在让我们看一下权限，或者说Spring Security中的<em>角色</em>和<em>权限</em>。</p>
<h3 id="什么是授权？"><a href="#什么是授权？" class="headerlink" title="什么是授权？"></a>什么是授权？</h3><p>以典型的电子商务网上商店为例。它可能由以下部分组成：</p>
<ul>
<li>网上商店本身。假设其网址为<code>*www.youramazinshop.com*</code>。</li>
<li>也许是呼叫中心代理的区域，他们可以在其中登录并查看客户最近购买的商品或包裹的位置。其网址可能是<code>*www.youramazinshop.com/callcenter*</code>。</li>
<li>一个单独的管理区域，管理员可以在其中登录和管理呼叫中心代理或网上商店的其他技术方面（例如主题，性能等）。其网址可能是<code>*www.youramazinshop.com/admin*</code>。</li>
</ul>
<p>这具有以下含义，因为仅对用户进行身份验证已不再足够：</p>
<ul>
<li>客户显然不应该能够访问呼叫中心<em>或</em>管理区域。只允许他在网站上购物。</li>
<li>呼叫中心代理应无法访问管理区域。</li>
<li>管理员可以访问网上商店，呼叫中心区域和管理员区域。</li>
</ul>
<p>简而言之，您要允许不同的用户根据其<em>权限</em>或<em>角色</em>进行不同的访问。</p>
<h3 id="什么是当局？什么是角色？"><a href="#什么是当局？什么是角色？" class="headerlink" title="什么是当局？什么是角色？"></a>什么是当局？什么是角色？</h3><p>简单：</p>
<ul>
<li>权限（以最简单的形式）只是一个字符串，它可以是：user，ADMIN，ROLE_ADMIN或53cr37_r0l3。</li>
<li>角色是具有<code>*ROLE_*</code>前缀的授权。因此，称为的角色<code>*ADMIN*</code>与称为的授权相同<code>*ROLE_ADMIN*</code>。</li>
</ul>
<p>角色和权限之间的区别纯粹是概念上的，这常常使Spring Security的新手感到困惑。</p>
<h3 id="为什么在角色和权限之间有区别？"><a href="#为什么在角色和权限之间有区别？" class="headerlink" title="为什么在角色和权限之间有区别？"></a>为什么在角色和权限之间有区别？</h3><p>老实说，我已经阅读了Spring Security文档以及有关此问题的几个相关StackOverflow线程，我无法给您一个明确的<em>好</em>答案。</p>
<h3 id="什么是GrantedAuthorities？什么是SimpleGrantedAuthorities？"><a href="#什么是GrantedAuthorities？什么是SimpleGrantedAuthorities？" class="headerlink" title="什么是GrantedAuthorities？什么是SimpleGrantedAuthorities？"></a>什么是GrantedAuthorities？什么是SimpleGrantedAuthorities？</h3><p>当然，Spring Security并不能让您<em>仅</em>使用String 来摆脱困境。有一个Java类代表您的权限String，一种流行的类型是SimpleGrantedAuthority。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleGrantedAuthority</span> <span class="keyword">implements</span> <span class="title">GrantedAuthority</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String role;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getAuthority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> role;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（注意：还有其他授权类，可以让您在字符串旁边存储其他对象（例如，主体），这里我不会覆盖它们。现在，我们仅使用SimpleGrantedAuthority。）</p>
<h3 id="1-UserDetailsService：在哪里存储和获取授权？"><a href="#1-UserDetailsService：在哪里存储和获取授权？" class="headerlink" title="1. UserDetailsService：在哪里存储和获取授权？"></a>1. UserDetailsService：在哪里存储和获取授权？</h3><p>假设您将用户存储在自己的应用程序中（认为：UserDetailsService），您将拥有<a href="https://www.marcobehler.com/guides/spring-security#users-table" target="_blank" rel="noopener">一个Users表</a>。</p>
<p>现在，您只需在其中添加一个名为“ authorities”的列即可。对于本文，我在这里选择了一个简单的字符串列，尽管它可以包含多个逗号分隔的值。另外，我也可以有一个完全独立的表AUTHORITIES，但是在本文的范围内，可以这样做。</p>
<p><strong>注意：</strong>回顾<a href="https://www.marcobehler.com/guides/spring-security#_what_are_authorities_what_are_roles" target="_blank" rel="noopener">什么是权威？什么是角色？</a>：您将<em>权限</em>（即字符串）保存到数据库。这些权限恰巧以ROLE_前缀开头，因此，就Spring Security而言，这些权限<em>也是</em>角色。</p>
<table>
<thead>
<tr>
<th>用户名</th>
<th>密码</th>
<th>当局</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><a href="mailto:john@doe.com">john@doe.com</a></td>
<td>{bcrypt} …</td>
<td>ROLE_ADMIN</td>
<td></td>
</tr>
<tr>
<td><a href="mailto:my@callcenter.com">my@callcenter.com</a></td>
<td>{sha256} …</td>
<td>ROLE_CALLCENTER</td>
<td></td>
</tr>
</tbody></table>
<p>剩下要做的唯一一件事情就是调整UserDetailsService以在该权限列中读取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDatabaseUserDetailsService</span> <span class="keyword">implements</span> <span class="title">UserDetailsService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span><br><span class="line">     User user = userDao.findByUsername(username);</span><br><span class="line">     List&lt;SimpleGrantedAuthority&gt; grantedAuthorities = user.getAuthorities().map(authority -&gt; <span class="keyword">new</span> SimpleGrantedAuthority(authority)).collect(Collectors.toList()); <span class="comment">// (1)</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), grantedAuthorities); <span class="comment">// (2)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>您只需将数据库列内的任何内容映射到SimpleGrantedAuthorities列表。做完了</li>
<li>同样，我们在这里使用Spring Security的UserDetails的基本实现。您也可以使用自己的类在此处实现UserDetails，甚至不必进行映射。</li>
</ol>
<h3 id="2-AuthenticationManager：在哪里存储和获取授权？"><a href="#2-AuthenticationManager：在哪里存储和获取授权？" class="headerlink" title="2. AuthenticationManager：在哪里存储和获取授权？"></a>2. AuthenticationManager：在哪里存储和获取授权？</h3><p>当用户来自第三方应用程序（例如Atlassian Cloud）时，您需要找出他们用于支持权限的概念。Atlassian Crowd具有“角色”的概念，但不赞成使用“组”。</p>
<p>因此，根据您使用的实际产品，您需要在AuthenticationProvider中将此映射到Spring Security授权。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtlassianCrowdAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line">        String username = authentication.getPrincipal().toString();</span><br><span class="line">        String password = authentication.getCredentials().toString();</span><br><span class="line"></span><br><span class="line">        atlassian.crowd.User user = callAtlassianCrowdRestService(username, password); <span class="comment">// (1)</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationException(<span class="string">"could not login"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserNamePasswordAuthenticationToken(user.getUsername(), user.getPassword(), mapToAuthorities(user.getGroups())); <span class="comment">// (2)</span></span><br><span class="line">    &#125;</span><br><span class="line">            <span class="comment">// other method ignored</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>注意：这不是<em>实际的</em> Atlassian Crowd代码，但可以达到目的。您针对REST服务进行身份验证，并获取一个JSON User对象，然后将其转换为atlassian.crowd.User对象。</li>
<li>该用户可以是一个或多个组的成员，这里假定只是字符串。然后，您可以简单地将这些组映射到Spring的“ SimpleGrantedAuthority”。</li>
</ol>
<h3 id="重新访问WebSecurityConfigurerAdapter以获得权限"><a href="#重新访问WebSecurityConfigurerAdapter以获得权限" class="headerlink" title="重新访问WebSecurityConfigurerAdapter以获得权限"></a>重新访问WebSecurityConfigurerAdapter以获得权限</h3><p>到目前为止，我们已经讨论了很多有关在Spring Security中为经过身份验证的用户存储和检索授权的信息。但是，如何通过Spring Security的DSL <em>保护</em>具有不同权限的URL？简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">          .authorizeRequests()</span><br><span class="line">            .antMatchers(<span class="string">"/admin"</span>).hasAuthority(<span class="string">"ROLE_ADMIN"</span>) <span class="comment">// (1)</span></span><br><span class="line">            .antMatchers(<span class="string">"/callcenter"</span>).hasAnyAuthority(<span class="string">"ROLE_ADMIN"</span>, <span class="string">"ROLE_CALLCENTER"</span>) <span class="comment">// (2)</span></span><br><span class="line">            .anyRequest().authenticated() <span class="comment">// (3)</span></span><br><span class="line">            .and()</span><br><span class="line">         .formLogin()</span><br><span class="line">           .and()</span><br><span class="line">         .httpBasic();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>要访问该<code>*/admin*</code>区域，您（即用户）需要经过认证<em>并且</em>具有权限（简单字符串）ROLE_ADMIN。</li>
<li>要访问该<code>*/callcenter*</code>区域，您需要进行身份验证<em>并</em>具有权限ROLE_ADMIN <em>或</em> ROLE_CALLCENTER。</li>
<li>对于任何其他请求，您不需要特定角色，但仍需要进行身份验证。</li>
</ol>
<p>请注意，上面的代码（1,2）<em>等效</em>于以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">  .authorizeRequests()</span><br><span class="line">    .antMatchers(<span class="string">"/admin"</span>).hasRole(<span class="string">"ADMIN"</span>) <span class="comment">// (1)</span></span><br><span class="line">    .antMatchers(<span class="string">"/callcenter"</span>).hasAnyRole(<span class="string">"ADMIN"</span>, <span class="string">"CALLCENTER"</span>) <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>现在，您无需调用“ hasAuthority”，而是调用“ hasRole”。<strong>注意</strong>：Spring Security将寻找<code>*ROLE_ADMIN*</code>对经过身份验证的用户调用的权限。</li>
<li>现在，您无需调用“ hasAnyAuthority”，而是调用“ hasAnyRole”。 <strong>注意</strong>：Spring Security将在经过身份验证的用户上查找称为<code>*ROLE_ADMIN*</code>或<code>*ROLE_CALLCENTER*</code>的授权。</li>
</ol>
<h3 id="hasAccess和SpEL"><a href="#hasAccess和SpEL" class="headerlink" title="hasAccess和SpEL"></a>hasAccess和SpEL</h3><p>最后但并非最不重要的是，配置授权最强大的方法是使用<em>访问</em>方法。它使您几乎可以指定任何有效的SpEL表达式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http</span><br><span class="line">  .authorizeRequests()</span><br><span class="line">    .antMatchers(<span class="string">"/admin"</span>).access(<span class="string">"hasRole('admin') and hasIpAddress('192.168.1.0/24') and @myCustomBean.checkAccess(authentication,request)"</span>) <span class="comment">// (1)</span></span><br></pre></td></tr></table></figure>

<ol>
<li>您正在检查用户是否具有ROLE_ADMIN，特定的IP地址以及自定义bean检查。</li>
</ol>
<p>要全面了解Spring的基于表达式的访问控制的功能，请查看<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#el-access" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="常见漏洞利用保护"><a href="#常见漏洞利用保护" class="headerlink" title="常见漏洞利用保护"></a>常见漏洞利用保护</h2><p>Spring Security可帮助您防御多种常见攻击。它从定时攻击开始（即，即使用户不存在，Spring Security也会始终在登录时对提供的密码进行加密），最后是针对高速缓存控制攻击，内容嗅探，点击劫持，跨站点脚本编写等的防护。</p>
<p>在本指南的范围内，不可能详细介绍每种攻击。因此，我们将只关注使大多数Spring Security新手失去最大支持的一种保护：跨站点请求伪造。</p>
<h3 id="跨站请求伪造：CSRF"><a href="#跨站请求伪造：CSRF" class="headerlink" title="跨站请求伪造：CSRF"></a>跨站请求伪造：CSRF</h3><p>如果您不熟悉CSRF，则可能需要观看<a href="https://www.youtube.com/watch?v=vRBihr41JTo" target="_blank" rel="noopener">此YouTube视频</a>，以快速掌握它。但是，快速的收获是，<strong>默认情况下，</strong> Spring Security使用有效的CSRF令牌保护所有传入的POST（或PUT / DELETE / PATCH）请求。</p>
<p>这意味着什么？</p>
<h4 id="CSRF和服务器端呈现的HTML"><a href="#CSRF和服务器端呈现的HTML" class="headerlink" title="CSRF和服务器端呈现的HTML"></a>CSRF和服务器端呈现的HTML</h4><p>想象一下与此有关的银行转帐表格或任何表格（例如登录表格），这些表格将由您的@Controllers在模板技术（如Thymeleaf或Freemarker）的帮助下呈现。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/transfer"</span> method=<span class="string">"post"</span>&gt;  &lt;!-- <span class="number">1</span> --&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"amount"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"routingNumber"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"account"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Transfer"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<p>启用Spring Security后，您<strong>将无法再提交该表单</strong>。因为Spring Security的CSRFFilter会在<strong>任何POST</strong>（PUT / DELETE）请求中寻找<em>其他隐藏参数</em>：所谓的CSRF令牌。</p>
<p>默认情况下，它会在<em>每个HTTP会话中</em>生成此类令牌并将其存储在该令牌中。而且，您需要确保将其注入到任何HTML表单中。</p>
<h4 id="CSRF代币和胸腺"><a href="#CSRF代币和胸腺" class="headerlink" title="CSRF代币和胸腺"></a>CSRF代币和胸腺</h4><p>由于Thymeleaf与Spring Security（与Spring Boot结合使用）具有良好的集成，因此您只需将以下代码段添加到任何表单中，即可从会话中自动将令牌注入到表单中。更好的是，如果您在表单中使用“ th：action”，则Thymeleaf会<em>自动</em>为您注入该隐藏字段，而无需手动进行。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"/transfer"</span> method=<span class="string">"post"</span>&gt;  &lt;!-- <span class="number">1</span> --&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"amount"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"routingNumber"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"account"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Transfer"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"$&#123;_csrf.parameterName&#125;"</span> value=<span class="string">"$&#123;_csrf.token&#125;"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- OR --&gt;</span><br><span class="line"></span><br><span class="line">&lt;form th:action=<span class="string">"/transfer"</span> method=<span class="string">"post"</span>&gt;  &lt;!-- <span class="number">2</span> --&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"amount"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"routingNumber"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> name=<span class="string">"account"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"submit"</span> value=<span class="string">"Transfer"</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>在这里，我们正在手动添加CSRF参数。</li>
<li>在这里，我们使用Thymeleaf的表单支持。</li>
</ol>
<p>注意：有关Thymeleaf的CSRF支持的更多信息，请参阅<a href="https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html" target="_blank" rel="noopener">官方文档</a>。</p>
<h4 id="CSRF和其他模板库"><a href="#CSRF和其他模板库" class="headerlink" title="CSRF和其他模板库"></a>CSRF和其他模板库</h4><p>我不能在本节中介绍所有模板库，但作为最后的选择，您始终可以将CSRFToken注入任何@Controller方法中，并将其简单地添加到模型中以在视图中呈现它，或直接将其作为HttpServletRequest请求属性访问。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMaping</span>(<span class="string">"/login"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(Model model, CsrfToken token)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// the token will be injected automatically</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/templates/login"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CSRF＆React或Angular"><a href="#CSRF＆React或Angular" class="headerlink" title="CSRF＆React或Angular"></a>CSRF＆React或Angular</h4><p>对于Javascript应用（例如React或Angular单页应用），情况有所不同。这是您需要做的：</p>
<ol>
<li>配置Spring Security以使用<a href="https://docs.spring.io/spring-security/site/docs/5.0.13.RELEASE/api/index.html?org/springframework/security/web/csrf/CookieCsrfTokenRepository.html" target="_blank" rel="noopener">CookieCsrfTokenRepository</a>，它将把CSRFToken放入cookie“ XSRF-TOKEN”（并将其发送到浏览器）。</li>
<li>使您的Javascript应用采用该Cookie值，并在每个POST（/ PUT / PATCH / DELETE）请求中将其作为“ X-XSRF-TOKEN” <em>标头</em>发送。</li>
</ol>
<p>对于完整的复制粘贴React示例，请查看以下出色的博客文章：<a href="https://developer.okta.com/blog/2018/07/19/simple-crud-react-and-spring-boot" target="_blank" rel="noopener">https</a> : <a href="https://developer.okta.com/blog/2018/07/19/simple-crud-react-and-spring-boot" target="_blank" rel="noopener">//developer.okta.com/blog/2018/07/19/simple-crud-react-and-spring-boot</a>。</p>
<h4 id="禁用CSRF"><a href="#禁用CSRF" class="headerlink" title="禁用CSRF"></a>禁用CSRF</h4><p>如果仅提供CSRF保护没有任何意义的无状态REST API，则将完全禁用CSRF保护。这是您的操作方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span></span></span><br><span class="line"><span class="class">   <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http</span><br><span class="line">      .csrf().disable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h2><p>坏蛋！本部分只是下一篇文章的预告片：Spring Security＆OAuth2。为什么？</p>
<p>因为Spring Security的OAuth2集成实际上是一个复杂的主题，并且足以容纳另外7,000-10,000个字，这不属于本文的范围。</p>
<p>敬请关注。</p>
<h2 id="春季整合"><a href="#春季整合" class="headerlink" title="春季整合"></a>春季整合</h2><h3 id="Spring安全性和Spring框架"><a href="#Spring安全性和Spring框架" class="headerlink" title="Spring安全性和Spring框架"></a>Spring安全性和Spring框架</h3><p>对于本文的大部分内容，您仅在应用程序的<em>Web层</em>上指定了安全配置。您通过WebSecurityConfigurerAdapter的DSL使用antMatcher或regexMatchers保护了某些URL。这是完美的安全标准方法。</p>
<p>除了保护您的Web层，还有“深度防御”的想法。这意味着除了保护URL外，您可能还希望保护业务逻辑本身。想想：您的@ Controllers，@ Components，@ Services甚至@Repositories。简而言之，您的Spring bean。</p>
<h3 id="方法安全性"><a href="#方法安全性" class="headerlink" title="方法安全性"></a>方法安全性</h3><p>该方法将被调用<code>*method security*</code>并通过注释工作，您基本上可以将其放置在Spring bean的任何公共方法上。您还需要通过将@EnableGlobalMethodSecurity批注放在ApplicationContextConfiguration上来显式启用方法安全性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(</span><br><span class="line">  prePostEnabled = <span class="keyword">true</span>, <span class="comment">// (1)</span></span><br><span class="line">  securedEnabled = <span class="keyword">true</span>, <span class="comment">// (2)</span></span><br><span class="line">  jsr250Enabled = <span class="keyword">true</span>) <span class="comment">// (3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YourSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>prePostEnabled属性启用对Spring <code>*@PreAuthorize*</code>和<code>*@PostAuthorize*</code>批注的支持。支持意味着，除非将标志设置为true，否则Spring将忽略此注释。</li>
<li>secureEnabled属性启用对<code>*@Secured*</code>注释的支持。支持意味着，除非将标志设置为true，否则Spring将忽略此注释。</li>
<li>jsr250Enabled属性启用对<code>*@RolesAllowed*</code>注释的支持。支持意味着，除非将标志设置为true，否则Spring将忽略此注释。</li>
</ol>
<h3 id="PreAuthorize，-Secured和-RolesAllowed有什么区别？"><a href="#PreAuthorize，-Secured和-RolesAllowed有什么区别？" class="headerlink" title="@ PreAuthorize，@ Secured和@RolesAllowed有什么区别？"></a>@ PreAuthorize，@ Secured和@RolesAllowed有什么区别？</h3><p>@Secured和@RolesAllowed基本相同，尽管@Secured是Spring特定的批注，带有spring-security-core依赖项，而@RolesAllowed是标准化的批注，位于javax.annotation-api依赖项中。这两个注释都将一个授权/角色字符串作为值。</p>
<p>@ PreAuthorize / @ PostAuthorize也是（较新的）Spring特定注释，并且比上述注释更强大，因为它们不仅可以包含授权/角色，还可以包含<em>任何</em>有效的SpEL表达式。</p>
<p>最后，<code>*AccessDeniedException*</code>如果您尝试访问权限/角色不足的受保护方法，则所有这些注释都将引发。</p>
<p>因此，让我们最后来看一下这些注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SomeService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Secured</span>(<span class="string">"ROLE_CALLCENTER"</span>) <span class="comment">// (1)</span></span><br><span class="line">    <span class="comment">// == @RolesAllowed("ADMIN")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BankAccountInfo <span class="title">get</span><span class="params">(...)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreAuthorize</span>(<span class="string">"isAnonymous()"</span>) <span class="comment">// (2)</span></span><br><span class="line">    <span class="comment">// @PreAuthorize("#contact.name == principal.name")</span></span><br><span class="line">    <span class="comment">// @PreAuthorize("ROLE_ADMIN")</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trackVisit</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如前所述，@ Secured将权限/角色作为参数。@RolesAllowed，同样。<strong>注意</strong>：请记住，这<code>*@RolesAllowed(&quot;ADMIN&quot;)*</code>将检查授予的权限<code>*ROLE_ADMIN*</code>。</li>
<li>如前所述，@ PreAuthorize接受权限，但也接受任何有效的SpEL表达式。有关像<code>*isAnonymous()*</code>上面这样的常见内置安全表达式的列表，而不是编写自己的SpEL表达式，请查看<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#el-access" target="_blank" rel="noopener">官方文档</a>。</li>
</ol>
<h3 id="我应该使用哪个注释？"><a href="#我应该使用哪个注释？" class="headerlink" title="我应该使用哪个注释？"></a>我应该使用哪个注释？</h3><p>这主要是一个同质性问题，而不是过多地将自己与Spring特定的API捆绑在一起（通常会提出这种观点）。</p>
<p>如果使用@Secured，请坚持使用它，不要在28％的其他bean中跳到@RolesAllowed注释，以实现<em>标准化</em>，但切勿完全通过。</p>
<p>首先，您可以始终使用@Secured并在需要时立即切换到@PreAuthorize。</p>
<h3 id="Spring-Security和Spring-Web-MVC"><a href="#Spring-Security和Spring-Web-MVC" class="headerlink" title="Spring Security和Spring Web MVC"></a>Spring Security和Spring Web MVC</h3><p>至于与Spring WebMVC的集成，Spring Security允许您做几件事：</p>
<ol>
<li>除了antMatchers和regexMatchers，您还可以使用mvcMatchers。区别在于，尽管antMatchers和regexMatchers基本上将URI字符串与通配符匹配，但mvcMatchers的行为与@RequestMappings <em>完全相同</em>。</li>
<li>将您当前已验证的主体注入@ Controller / @ RestController方法。</li>
<li>将当前会话CSRFToken注入@ Controller / @ RestController方法。</li>
<li>正确处理<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#mvc-async" target="_blank" rel="noopener">异步请求</a>处理的安全性。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/messages/inbox"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">findMessagesForUser</span><span class="params">(@AuthenticationPrincipal CustomUser customUser, CsrfToken token)</span> </span>&#123;  <span class="comment">// (1) (2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// .. find messages for this user and return them ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果对用户进行了身份验证，则@AuthenticationPrincipal将注入主体；如果没有对用户进行身份验证，则将注入null。该主体是来自UserDetailsService / AuthenticationManager的对象！</li>
<li>或者，您可以将当前会话CSRFToken注入每个方法中。</li>
</ol>
<p>如果不使用@AuthenticationPrincipal批注，则必须通过SecurityContextHolder自己获取主体。在旧版Spring Security应用程序中经常看到的一种技术。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/messages/inbox"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">findMessagesForUser</span><span class="params">(CsrfToken token)</span> </span>&#123;</span><br><span class="line">         SecurityContext context = SecurityContextHolder.getContext();</span><br><span class="line">         Authentication authentication = context.getAuthentication();</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (authentication != <span class="keyword">null</span> &amp;&amp; authentication.getPrincipal() <span class="keyword">instanceof</span> UserDetails) &#123;</span><br><span class="line">             CustomUser customUser = (CustomUser) authentication.getPrincipal();</span><br><span class="line">             <span class="comment">// .. find messages for this user and return them ...</span></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// todo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring-Security和Spring-Boot"><a href="#Spring-Security和Spring-Boot" class="headerlink" title="Spring Security和Spring Boot"></a>Spring Security和Spring Boot</h3><p>每当您将<em>spring-boot-starter-security</em>依赖项添加到Spring Boot项目中时，Spring Boot确实只会为您<a href="https://www.marcobehler.com/guides/spring-boot" target="_blank" rel="noopener">预先配置Spring Security</a>。</p>
<p>除此之外，所有安全性配置都是通过普通的Spring Security概念（例如WebSecurityConfigurerAdapter，身份验证和授权规则）完成的，而这些概念本身与Spring Boot无关。</p>
<p>因此，您在本指南中阅读的所有内容都将1：1应用于将Spring Security与Spring Boot结合使用。而且，如果您不了解一般的安全性，请不要期望正确地了解这两种技术如何协同工作。</p>
<h3 id="春季安全与胸腺"><a href="#春季安全与胸腺" class="headerlink" title="春季安全与胸腺"></a>春季安全与胸腺</h3><p>Spring Security与Thymeleaf集成良好。它提供了特殊的Spring Security Thymeleaf方言，可让您将安全性表达式直接放入Thymeleaf HTML模板中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">"isAuthenticated()"</span>&gt;</span></span><br><span class="line">  This content is only shown to authenticated users.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">"hasRole('ROLE_ADMIN')"</span>&gt;</span></span><br><span class="line">  This content is only shown to administrators.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">sec:authorize</span>=<span class="string">"hasRole('ROLE_USER')"</span>&gt;</span></span><br><span class="line">  This content is only shown to users.</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>有关这两种技术如何协同工作的完整且更详细的概述，请<a href="https://www.thymeleaf.org/doc/articles/springsecurity.html" target="_blank" rel="noopener">参阅官方文档</a>。</p>
<h2 id="常问问题"><a href="#常问问题" class="headerlink" title="常问问题"></a>常问问题</h2><h3 id="什么是最新的Spring-Security版本？"><a href="#什么是最新的Spring-Security版本？" class="headerlink" title="什么是最新的Spring Security版本？"></a>什么是最新的Spring Security版本？</h3><p>截至2020年4月，即5.3.1版本。</p>
<p>请注意，如果您使用的是Spring Boot定义的Spring Security依赖关系，则可能使用的是较旧的Spring Security版本，如5.2.1。</p>
<h3 id="较旧的Spring-Security版本与最新版本兼容吗？"><a href="#较旧的Spring-Security版本与最新版本兼容吗？" class="headerlink" title="较旧的Spring Security版本与最新版本兼容吗？"></a>较旧的Spring Security版本与最新版本兼容吗？</h3><p>Spring Security最近已经发生了相当大的变化。因此，您需要找到目标版本的迁移指南并逐步进行操作：</p>
<ul>
<li>Spring Security 3.x至4.x→ <a href="https://docs.spring.io/spring-security/site/migrate/current/3-to-4/html5/migrate-3-to-4-jc.html" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/migrate/current/3-to-4/html5/migrate-3-to-4-jc.html</a></li>
<li>Spring Security 4.x到5.x（&lt;5.3）→ <a href="https://docs.spring.io/spring-security/site/docs/5.0.15.RELEASE/reference/htmlsingle/#new（不是真正的指南，但有新消息）" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/5.0.15.RELEASE/reference/htmlsingle/#new（不是真正的指南，但有新消息）</a></li>
<li>Spring Security 5.x至5.3→ <a href="https://docs.spring.io/spring-security/site/docs/5.3.1.RELEASE/reference/html5/#new（不是真正的指南，而是新功能）" target="_blank" rel="noopener">https://docs.spring.io/spring-security/site/docs/5.3.1.RELEASE/reference/html5/#new（不是真正的指南，而是新功能）</a></li>
</ul>
<h3 id="为了使Spring-Security正常工作，我需要添加哪些依赖项？"><a href="#为了使Spring-Security正常工作，我需要添加哪些依赖项？" class="headerlink" title="为了使Spring Security正常工作，我需要添加哪些依赖项？"></a>为了使Spring Security正常工作，我需要添加哪些依赖项？</h3><h4 id="平原春季项目"><a href="#平原春季项目" class="headerlink" title="平原春季项目"></a>平原春季项目</h4><p>如果您使用的是普通的Spring项目（<em>不是</em> Spring Boot），则需要向项目中添加以下两个Maven / Gradle依赖项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>您<strong>还</strong>需要在web.xml或Java配置中配置SecurityFilterChain。<a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/#ns-web-xml" target="_blank" rel="noopener">在这里</a>查看如何进行。</p>
<h4 id="春季启动项目"><a href="#春季启动项目" class="headerlink" title="春季启动项目"></a>春季启动项目</h4><p>如果您正在使用Spring Boot项目，则需要在项目中添加以下Maven / Gradle依赖项：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>其他所有内容将自动为您配置，您可以立即开始编写WebSecurityConfigurerAdapter。</p>
<h3 id="如何在Spring-Security中以编程方式访问当前经过身份验证的用户？"><a href="#如何在Spring-Security中以编程方式访问当前经过身份验证的用户？" class="headerlink" title="如何在Spring Security中以编程方式访问当前经过身份验证的用户？"></a>如何在Spring Security中以编程方式访问当前经过身份验证的用户？</h3><p>如本文所述，Spring Security将当前已通过身份验证的用户（或更确切地说是SecurityContext）存储在SecurityContextHolder内部的线程局部变量中。您可以这样访问它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SecurityContext context = SecurityContextHolder.getContext();</span><br><span class="line">Authentication authentication = context.getAuthentication();</span><br><span class="line">String username = authentication.getName();</span><br><span class="line">Object principal = authentication.getPrincipal();</span><br><span class="line">Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();</span><br></pre></td></tr></table></figure>

<p>请注意，如果您未登录，Spring Security <em>默认情况下</em>会<code>*AnonymousAuthenticationToken*</code>在SecurityContextHolder上设置一个身份验证。这会引起一些混乱，因为人们自然会期望在那里有一个null值。</p>
<h3 id="AntMatchers：常见示例"><a href="#AntMatchers：常见示例" class="headerlink" title="AntMatchers：常见示例"></a>AntMatchers：常见示例</h3><p>一个无意义的示例，显示了最有用的antMatcher（和regexMatcher / mvcMatcher）可能性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    http</span><br><span class="line">      .authorizeRequests()</span><br><span class="line">      .antMatchers(<span class="string">"/api/user/**"</span>, <span class="string">"/api/ticket/**"</span>, <span class="string">"/index"</span>).hasAuthority(<span class="string">"ROLE_USER"</span>)</span><br><span class="line">      .antMatchers(HttpMethod.POST, <span class="string">"/forms/**"</span>).hasAnyRole(<span class="string">"ADMIN"</span>, <span class="string">"CALLCENTER"</span>)</span><br><span class="line">      .antMatchers(<span class="string">"/user/**"</span>).access(<span class="string">"@webSecurity.check(authentication,request)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何在Spring-Security中使用自定义登录页面？"><a href="#如何在Spring-Security中使用自定义登录页面？" class="headerlink" title="如何在Spring Security中使用自定义登录页面？"></a>如何在Spring Security中使用自定义登录页面？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  http</span><br><span class="line">      .authorizeRequests()</span><br><span class="line">          .anyRequest().authenticated()</span><br><span class="line">          .and()</span><br><span class="line">      .formLogin()</span><br><span class="line">          .loginPage(<span class="string">"/login"</span>) <span class="comment">// (1)</span></span><br><span class="line">          .permitAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>您的自定义登录页面的URL。指定此选项后，自动生成的登录页面将消失。</li>
</ol>
<h3 id="如何使用Spring-Security进行程序化登录？"><a href="#如何使用Spring-Security进行程序化登录？" class="headerlink" title="如何使用Spring Security进行程序化登录？"></a>如何使用Spring Security进行程序化登录？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UserDetails principal = userDetailsService.loadUserByUsername(username);</span><br><span class="line">Authentication authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(principal, principal.getPassword(), principal.getAuthorities());</span><br><span class="line">SecurityContext context = SecurityContextHolder.createEmptyContext();</span><br><span class="line">context.setAuthentication(authentication);</span><br></pre></td></tr></table></figure>

<h3 id="如何仅针对某些路径禁用CSRF？"><a href="#如何仅针对某些路径禁用CSRF？" class="headerlink" title="如何仅针对某些路径禁用CSRF？"></a>如何仅针对某些路径禁用CSRF？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      http</span><br><span class="line">       .csrf().ignoringAntMatchers(<span class="string">"/api/**"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="鳍"><a href="#鳍" class="headerlink" title="鳍"></a>鳍</h2><p>如果到目前为止，您已经了解了Spring Security生态系统的复杂性，即使没有OAuth2也是如此。总结一下：</p>
<ol>
<li>如果您对Spring Security的FilterChain的工作原理及其默认的漏洞利用保护有什么基本的了解（请考虑：CSRF），它会有所帮助。</li>
<li>确保了解身份验证和授权之间的区别。另外，还需要为特定的身份验证工作流程指定@Beans。</li>
<li>确保您了解Spring Security的WebSecurityConfigurerAdapter的DSL以及基于注释的方法安全性。</li>
<li>最后但并非最不重要的一点是，它有助于仔细检查Spring Security与其他框架和库（例如Spring MVC或Thymeleaf）的集成。</li>
</ol>
<p>今天足够了，因为那是一个很大的旅程，不是吗？谢谢阅读！</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">li yang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://liy05.github.io/2020/04/10/SrpingSecurity/">http://liy05.github.io/2020/04/10/SrpingSecurity/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://liy05.github.io" target="_blank">li yang</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/spring-security/">spring security</a></div><div class="post_share"><div class="social-share" data-image="/img/post.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/04/10/oauth2/"><img class="next_cover lazyload" data-src="/img/post.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">spring security oauth2 配置</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/10/oauth2/" title="spring security oauth2 配置"><img class="relatedPosts_cover lazyload"data-src="/img/post.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-10</div><div class="relatedPosts_title">spring security oauth2 配置</div></div></a></div></div><div class="clear_both"></div></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By li yang</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js" ></script><script src="/js/utils.js" ></script><script src="/js/main.js" ></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>